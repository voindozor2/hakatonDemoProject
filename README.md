# БаZа 134
## **Полуфинал BEST Hack '22**
## Направление **Java Backend**
#### [Ссылка на этот репозиторий](https://github.com/Artemidividiy/hakatonDemoProject)
## Участники:
+ ### Ерхов Вадим Игоревич ([V4D1MECHE](https://github.com/V4D1MECHE)) (капитан)
+ ### Гунин Игорь Павлович ([notblank00](https://github.com/notblank00))
+ ### Касьяник Артемий Иванович ([Artemidividiy](https://github.com/Artemidividiy))
+ ### Ларшина Мария Андреевна ([larmari](https://github.com/larmari))

---

## Причина ошибки:
При запуске приложения происходит вызов метода `SenderService.sendTestMessages()`, который отправляет в очередь 80 сообщений с одинаковым полем `name`:
```java
public void sendTestMessages() throws JsonProcessingException {
    byte[] array = new byte[14];
    new Random().nextBytes(array);
    String name = DigestUtils.md5DigestAsHex(array);

    for (int i = 0; i < 80; i++) {
        rabbitTemplate.convertAndSend("hakatonDemoQueue",name);
    }
}
```

Сообщения, выходящие из очереди обрабатываются методом `AmqpListener.hakatonDemoQueue(...)`:

```java
@RabbitListener(queues = "hakatonDemoQueue")
private void hakatonDemoQueue(String message) {
    domainService.saveHakatonEntity(new SendingDto(message));
}
```

Этот метод создает объект типа `SendingDto` и передает его в метод `DomainService.saveHakatonEntity(...)`. Т. к. единственное поле `String name` в классе `HakatonEntity`, которое передается в конструктор, помечено для ORM как **уникальный идентификатор** (**первичный ключ**) записи, СУБД **не допускает** существования в таблице двух записей с одинаковыми значениями этого поля.


```java
@Id
private String name;
```

Для того, чтобы предотвратить ошибки SQL, метод `DomainService.saveHakatonEntity(...)` перед попыткой записи нового объекта в таблицу проверяет наличие в ней объекта с таким же идентификатором, и только в случае отсутствия такого объекта создается новая запись:

```java
public void saveHakatonEntity(SendingDto sendingDto) {
    if(!hakatonEntityRepository.existsHakatonEntityByName(sendingDto.getName())) {
        hakatonEntityRepository.save(new HakatonEntity(sendingDto.getName()));
    }
}
```

Однако, вследствие **параллельного выполнения нескольких аналогичных процессов**, при добавлении одинаковых записей возникает ситуация **конкурентного доступа** (race condition): между проверкой отсутствия объекта и записью нового объекта в параллельном потоке происходит запись объекта с таким же идентификатором, что приводит к аномалии **фантомного чтения** (phantom read). Таким образом во время проверки конфликтующей строки в таблице нет, поэтому далее происходит попытка добавления строки, но в момент добавления строка с таким идентификатором уже существует в таблице. Это приводит к конфликтной ситуации, о которой и сигнализирует ошибка:

```sql
o.h.engine.jdbc.spi.SqlExceptionHelper: ERROR: duplicate key value violates unique constraint "hakaton_entity_pkey"
```

##### Перевод: Повторяющееся значение ключа нарушает ограничение уникальности "hakaton_entity_pkey"
---
## Метод устранения ошибки
Для устранения проблемы конкурентного доступа было принято решение использовать стандартный функционал реляционных СУБД, фреймворка Spring и ORM-библиотеки Hibernate. 

Для того, чтобы исключить возможность конкурентного доступа к данным, наиболее оптимальным решением является использование механизма **изоляции транзакций**, предоставляемого РСУБД: два запроса к базе данных, между моментами выполнения которых необходимо **сохранить состояние таблицы неизменным** (запрос проверки существования строки и запрос добавления новой строки), необходимо объединить в одну **транзакцию**. Созданную транзакцию также необходимо **изолировать от влияния параллельных изменений**.

Spring и Hibernate предоставляют возможность **объединить в одну транзакцию** все SQL-запросы, производимые во время выполнения конкретного метода:

```java
@Transactional(propagation = Propagation.REQUIRES_NEW, isolation = Isolation.REPEATABLE_READ)
public void saveHakatonEntity(SendingDto sendingDto) {
    if(!hakatonEntityRepository.existsHakatonEntityByName(sendingDto.getName())) {
        hakatonEntityRepository.save(new HakatonEntity(sendingDto.getName()));
    }
}
```

Аннотация `@Transactional` означает, что при вызове метода необходимо **запустить транзакцию** и **завершить ее при выходе из метода**. При возникновении исключения во время выполнении метода или ошибки SQL при выполнении какого-либо запроса внутри транзакции, она **откатывается**.

Т. к. в данном случае транзакции используются в первую очередь для **изоляции и атомизации** последовательности запросов, использовать уже запущенную транзакцию **недопустимо** и необходимо **создавать новую при каждом вызове** (`propagation = Propagation.REQUIRES_NEW`).

Также для того, чтобы параллельные изменения не влияли на процессы внутри транзакции, необходимо установить уровень изолированности **не ниже `REPEATABLE READ`** (`isolation = Isolation.REPEATABLE_READ`).

##### Примечание: несмотря на то, что стандарт SQL допускает фантомные чтения при уровне изоляции `REPEATABLE READ`, в PostgreSQL изменения, внесенные конкурентными транзакциями **невидимы** для процессов внутри транзакции. Также если две параллельные транзакции будут производить запись строк с одинаковым идентификатором, это приведет к откату одной из транзакций и исключения не произойдет.

---

Механизм изоляции транзакций предпочтительнее использования синхронного (`synchronized`) метода для проверки и записи строк в таблицу, т. к. изоляция транзакций **может позволить параллельное выполнение запросов** в случае, если они работают с различными фрагментами таблицы, что существенно эффективнее и **не создает "бутылочного горлышка"** при обработке запроса.

## Вывод
Ошибка была устранена и предотвращена возможность возникновения проблем, связанных с конкурентным доступом к данным в БД. Вместо синхронизации метода в один поток был выбран механизм изоляции транзакций, предоставляемый СУБД и делающий обработку запросов потенциально более эффективной.
